CRUD

-creo il progetto con Maven aggiungendo alcune dependencies
-faccio la configurazione del progetto

-prossimo passo prima di far partire il progetto è settare il database altrimenti non parte l'applicazione

-creo il database db_pizzeria

-nelle application.properties inserisco le rotte e le password del database

        #data source
        spring.datasource.url=jdbc:mysql://localhost:3306/db_pizzeria
        spring.datasource.username=root
        spring.datasource.password=root

-Ora possiamo far partire l'applicazione è collegato con il database

-Ora dobbiamo dire al database le azioni che farà incolliamo questa riga sempre in application.properties
in questo caso mettiamo create percè dobbiamo creare la tabella e le colonne

        # Hibernate ddl auto (create, create-drop, validate, update)
        spring.jpa.hibernate.ddl-auto=create


-Questo aiuta noi a vedere SQL in console formattato e comprensibile

            # Log SQL query (no in production)
            spring.jpa.show-sql=true
            spring.jpa.properties.hibernate.format_sql=true

-Per ultimo questo della cache


            spring.thymeleaf.cache=false


/////////////////////////////////////////////////////////////////////////////////////////////////////////////

-CREAZIONE TABELLA

-dobbiamo creare l'entità Pizza con i vari attributi
-creo una cartella model e dentro una classe Pizza
-Specifichiamo che è un @Entity e cominciamo a dargli gli attributi
-Id che dovrà essere autoincrementale (@GeneratedValue(strategy = GenerationType.IDENTITY))
e dobbiamo specificare che questoè l'@id
-insriamo tutti gli attributi
-inseriamo getting e setter


            package model;

            import jakarta.persistence.Entity;
            import jakarta.persistence.GeneratedValue;
            import jakarta.persistence.GenerationType;
            import jakarta.persistence.Id;

            @Entity
            public class Pizza {

                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Integer id;

                private String description;
                private String photoUrl;
                private double price;

                public Integer getId() {
                    return id;
                }

                public void setId(Integer id) {
                    this.id = id;
                }

                public String getDescription() {
                    return description;
                }

                public void setDescription(String description) {
                    this.description = description;
                }

                public String getPhotoUrl() {
                    return photoUrl;
                }

                public void setPhotoUrl(String photoUrl) {
                    this.photoUrl = photoUrl;
                }

                public double getPrice() {
                    return price;
                }

                public void setPrice(double price) {
                    this.price = price;
                }
            }

-facciamo partire l'app e dovremmo avere tutte le colonne
-adesso dobbiamo inserire i dati in tabella
-creiamo un file import.sql e mettimao dentro la Insert con tutti gli attributi della pizza

    INSERT INTO pizzas (created_at, description, name, photo_url, price) VALUES ('2023-11-09T11:35:00','pizza salsa e mozzarella', 'Margherita','https://www.tavolartegusto.it/wp/wp-content/uploads/2020/05/Pizza-napoletana-Ricetta-della-Pizza-Napoletana-Pizza-Margherita.jpg', 5.00);

-prossimo passaggio devo creare la BookRepository -> metto in una repository e faccio una interfaccia e scrivo
devo mettere il dato(Pizza) e l'entità dell'id

        public interface BookRepository extends JpaRepository<Pizza, Integer> {

        }

-Ora voglio vedere i miei dati quindi creo il controller
-richiamo il repository e lo metto dentro una lista di <Pizza> e faccio .findAll


               @Controller
               @RequestMapping("/pizzas")
               public class PizzaController {


                   private PizzaRepository PizzaRepository;

                   @Autowired
                   public PizzaController(com.experis.springlamiapizzeriacrud.repository.PizzaRepository pizzaRepository) {
                       PizzaRepository = pizzaRepository;
                   }

                   @GetMapping
                   public String index(Model model) {
                       List<Pizza> pizzaList = PizzaRepository.findAll();
                       model.addAttribute( " pizzaList ", pizzaList );
                       return "pizzas/pizzas-list";
                   }
               }


-posso creare i fragments

        <html xmlns:th="http://www.thymeleaf.org">

        <head>
            <th:block th:fragment="headResources(title)">
                <meta charset="UTF-8">
                <meta name="viewport"
                      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
                <meta http-equiv="X-UA-Compatible" content="ie=edge">
                <link rel="stylesheet" th:href="@{/webjars/font-awesome/6.4.2/css/all.min.css}">
                <link rel="stylesheet" th:href="@{/webjars/bootstrap/5.3.2/css/bootstrap.min.css}">
                <script th:src="@{/webjars/bootstrap/5.3.2/js/bootstrap.bundle.min.js}" defer></script>
                <title th:text="${title}"></title>
            </th:block>

        </head>

        </html>

-creo l'html con una tabella

           <body>

           <nav th:replace="fragments/navbar :: topNavbar('pizzas')"></nav>

           <h1>Lista delle pizze</h1>

           <table class="table">
               <thead>
               <tr>
                   <th>Name</th>
                   <th>Immagine</th>
                   <th>Prezzo</th>
                   <th></th>
               </tr>
               </thead>
               <tbody>
               <tr th:each="pizza : ${pizzaList}" th:object="${pizza}">
                   <td th:text="*{name}"></td>
                   <td><img th:src="*{photo_url}" style="max-width: 100px; max-height: 100px;"/></td>
                   <td th:text="*{price}"></td>
               </tr>
               </tbody>
           </table>


           </body>
           </html>

-creo il fragment per la navBar

            <html xmlns:th="http://www.thymeleaf.org">
            <body>
            <nav th:fragment="topNavbar(area)" class="navbar navbar-expand-lg bg-primary navbar-dark">

                <div class="container-fluid">
                    <a class="navbar-brand" th:href="@{/pizzas}">Lista pizze</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                            data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                            aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                            <li class="nav-item">
                                <a class="nav-link" th:classAppend="${area == 'pizzas' ? 'active' : ''}"
                                   th:href="@{/pizzas}">Pizzas</a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" th:classAppend="${area == 'users' ? 'active' : ''}"
                                   th:href="@{/users}">Users</a>
                            </li>
                        </ul>

                    </div>
                </div>

            </nav>
            </body>
            </html>


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


  ERRORS

-posso creare delle pagini di errore per il 404 o 500 posso farlo creando una directory error
e cimetto dentrp 2 classi 4xx e 5xx

        <!doctype html>
        <html lang="en" xmlns:th="http://www.thymeleaf.org">
        <head th:insert="fragments/resources :: headResources('Error')"></head>
        <body>
        <div class="container">
            <h1>I CANNOT RESPOND TO YOUR REQUEST</h1>
            <div th:insert="fragments/resources :: errorDetails"></div>
            <a th:href="@{/pizzas}" class="btn btn-primary">Go back to home</a>
        </div>
        </body>
        </html>

-e fare un fragment con i vari messaggi di errore -> status message exception e trace sono custom

            <th:block th:fragment="errorDetails">
                <p th:text="${status}"></p>
                <p th:text="${message}"></p>
                <p th:text="${exception}"></p>
                <p th:text="${trace}"></p>
            </th:block>

 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  SHOW


  -creiamo un controller per la show detail della pizza

             @GetMapping("/show/{id}")
                public String show(@PathVariable Integer id, Model model) {
                    return "pizzas/show";
                }

-e una pagina html di dettaglio


                <!doctype html>
                <html lang="en" xmlns:th="http://www.thymeleaf.org">
                <head th:insert="fragments/resources :: headResources('Pizza List')"></head>
                <body>
                <nav th:replace="fragments/navbar :: topNavbar('pizzas')"></nav>

                <h1>Pizza Detail</h1>

                </body>
                </html>

-ora con http://localhost:8080/pizzas/show/1 potremmo vedere la pagina show


-torno nel controller e inserisco -> cerca per id e usa una classe Optional ha dei metodi che mi dice se è
vuota o piena se il result.isPresent(); mi restituisce true allora c'è e posso fare il return altrimenti do errore

    Optional<Pizza> result = PizzaRepository.findById( id );
    if (result.isPresent()) {
        return "pizzas/show";
    } else {
      throw new ResponseStatusException( HttpStatus.NOT_FOUND, "book with id " + id + " not found" );
     }

-ora manca solo passare i dettagli della pizza nel template

     if (result.isPresent()) {
          model.addAttribute("pizza", result.get());
          return "pizzas/show";

-vado nel template e metto il nome la descrizione l'immagine e il prezzo e il created_at

          <div class="container" th:object="${pizza}">
              <h1 th:text="*{name}"></h1>
              <hr>
              <dl>
                  <dt>Description</dt>
                  <dd th:text="*{description}"></dd>
                  <dd><img th:src="*{photo_url}" style="max-width: 100px; max-height: 100px;"/></dd>
                  <dt>Prezzo</dt>
                  <dd th:text="*{price}">></dd>
                  <dt>Added to catalog</dt>
                  <dd th:text="*{#temporals.format(created_at, 'yyyy-MM-dd')}"></dd>

              </dl>
          </div>

- bisogna aggiungere alle pizzas-list un link per andare nel dettaglio della pizza

         <td>
            <a th:href="@{/pizzas/show/{id}(id=*{id})}" title="details"><i class="fa-solid fa-pizza-slice"></i></a>
        </td>

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

    RICERCA

- posso cercare per nome della pizza

-vado in pizza repository e inserisco

        public interface PizzaRepository extends JpaRepository<Pizza, Integer> {
            List<Pizza> findByNameContainingIgnoreCase(String nameKeyword);
        }

-questo mi permette di creare una query per fare una chiamata per nome
-mettiamo un box ricerca nell'html gli diamo un action e un metodo get al form
poi name="search" e il valore è param.search


            <div class="d-flex align-items-center justify-content-between">
                    <h1>Book List</h1>
                    <form th:action="@{/pizzas}" method="GET">
                        <div class="input-group">
                            <input
                                    type="text"
                                    placeholder="Search by name"
                                    class="form-control" name="search"
                                    th:value="${param.search}"
                            >
                            <button class="btn btn-primary" type="submit">Search</button>
                        </div>

                    </form>
                </div>


-ora devo tornare nella index e implemantare il metodo se il parametro di ricerca è presente filtro la lista dei libri
 altrimenti prendo tutti i libri non filtrati bookRepository recupera da database la lista di tutti i libri

             @GetMapping
                public String index(@RequestParam Optional<String> search, Model model) {
                    List<Pizza> pizzaList;
                    if (search.isPresent()) {

                        pizzaList = PizzaRepository.findByNameContainingIgnoreCase( search.get() );
                    } else {

                        pizzaList = PizzaRepository.findAll();
                    }

                    model.addAttribute( "pizzaList", pizzaList );
                    return "pizzas/pizzas-list";
                }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    CREATE

- per creare una create devo avere due controller diversi uno che mi porta della create una dello store
-creiamo il controller della create che ci manderà su una pagina dove metterò il mio form

            @GetMapping("/create")
            public String create() {
                return "pizzas/create";
            }

-creo una pagina html chiamata create
- ora inserisco nella pizzas-list il link a questa nuova pagina

            <div class="my-3">
                 <a th:href="@{/pizzas/create}" class="btn btn-primary">Add new pizza</a>
             </div>

-ora torno nel controller e devo passare al template una pizza vuota ma con tutti i parametri
(nome, descrizione ecc) lo faccio con il model e creando una nuova pizza

           @GetMapping("/create")
            public String create(Model model) {
                model.addAttribute( "pizza", new Pizza() );
                return "pizzas/create";
            }

-ora nel' html ho la pizza e i suoi parametri il th:object="${pizza}" è quello che mi arriva dal controller
il th:field= è il name e il value insieme


            <div class="container my-5">
                <h1>Create a new pizza</h1>

                <div>
                    <form id="pizza-create" method="POST" th:action="@{/pizzas/create/store}" th:object="${pizza}" class="row gy-2">
                        <div class="mb-3">
                            <label for="name" class="form-label">Name</label>
                            <input type="text" class="form-control" id="name" th:field="*{name}">
                        </div>
                        <div class="mb-3">
                            <label for="description" class="form-label">Insert description</label>
                            <textarea class="form-control" id="description" rows="3" th:field="*{description}"></textarea>
                        </div>
                        <div class="mb-3">
                            <label for="photo_url" class="form-label">Insert image</label>
                            <input type="text" class="form-control" id="photo_url" th:field="*{photo_url}">
                        </div>
                        <div class="mb-3">
                            <label for="price" class="form-label">Insert price</label>
                            <input type="number" class="form-control" id="price" th:field="*{price}">
                        </div>

                        <div>
                            <button class="btn btn-primary" type="submit">Save</button>
                            <a th:href="@{/pizzas}" class="btn bg-danger text-white">Cancel</a>
                        </div>
                    </form>

                </div>

            </div>

-ora devo creare il controller per la post con lo store per poter inviare i dati al database -> method="POST" th:action="@{/pizzas/create/store}"
-gli do il  Pizza formPizza così lui è in grado di ricostruire una pizza in base ai dati che gli ho passato
- formPizza.setCreated_at( LocalDateTime.now() ); gli setto a mano la Created_at in quanto no la chiedo all'utente

                 @PostMapping("/create/store")
                   public String store(Model model, Pizza formPizza) {
                       formPizza.setCreated_at( LocalDateTime.now() );
                       PizzaRepository.save( formPizza );
                       return "redirect:/pizzas";
                   }


////////////////////////////////////////////////////////////////////////////////////////////////////////////


   VALIDAZIONI

-inserisco questa dependecy

                   <dependency>
                        <groupId>org.springframework.boot</groupId>
                         <artifactId>spring-boot-starter-validation</artifactId>
                   </dependency>

-per le validazioni vado sul model e implemento con la nuova libreria le validazioni


                        @NotBlank
                        @Size(max = 250)
                        private String name;

                        @NotBlank
                        @Lob
                        private String description;

                        @NotBlank
                        private String photo_url;

                        @NotNull
                        @Digits(integer = 6, fraction = 2)
                        private double price;


-ora torno nel controller create e aggiungo @valid così viene controllato basandosi su quello che
ho scritto nel model
-inserisco anche BindingResult BindingResult che mi salva gli errori


                            @PostMapping("/create/store")
                            public String store(@Valid Pizza formPizza, BindingResult BindingResult) {
                                formPizza.setCreated_at( LocalDateTime.now() );
                                PizzaRepository.save( formPizza );
                                return "redirect:/pizzas";
                            }

-inserisco la condizio che se c'è un errore mi reindirizza alla stessa pagina così l'utente puoò correggere



                                 @PostMapping("/create/store")
                                 public String store(@Valid @ModelAttribute("pizza") Pizza formPizza, BindingResult BindingResult) {

                                     if (BindingResult.hasErrors()) {
                                         return "pizzas/create";
                                     }

                                     formPizza.setCreated_at( LocalDateTime.now() );
                                     PizzaRepository.save( formPizza );
                                     return "redirect:/pizzas";
                                 }

- adesso metto i messaggi nell'html usoo th:errorClass="is-invalid" che è una classe di bootsrap
-#fields.hasErrors('name') qui metto il campo da validare th:each="err : ${#fields.errors('name')} itero sugli errori e prendo
-l'erore del nome th:text="${err} mostro l'errore a schermo



                                 <label for="name" class="form-label">Name</label>
                                  <input type="text" class="form-control" id="name" th:field="*{name}" th:errorClass="is-invalid">
                                      <div th:if="${#fields.hasErrors('name')}" class="invalid-feedback">
                                           <ul>
                                               <li th:each="err : ${#fields.errors('name')}" th:text="${err}"></li>
                                            </ul>
                                       </div>


-inserisco gli errori come messaggio

                                    @NotBlank(message = "name must not be blank")
                                    @Size(max = 255, message = "Length must be less than 255")

                                    private String name;
                                    @NotBlank(message = "description must not be blank")

                                    @Lob
                                    private String description;
                                    @NotBlank(message = "photo_url must not be blank")
                                    private String photo_url;

                                    @DecimalMin(value = "0.01", message = "Price must be greater than 0")
                                    @DecimalMax(value = "999999.99", message = "Price must not exceed 999999.99")
                                    private double price;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


      EDIT/UPDATE

-primo passo è creare il link che mi porta al controller e quindi alla pagina di edit
-aggiungo in pizzas list la nuova icona con il link

                    <td>
                        <a th:href="@{/pizzas/edit/{id}(id=*{id})}" title="edit"><i class="fa-solid fa-pen-to-square"></i></a>
                     </td>

-ora faccio il controller -> passo l'id se è presente mostro la pagina "pizzas/edit" altrimenti mando l'eccezione


                       @GetMapping("/edit/{id}")
                           public String edit(@PathVariable Integer id, Model model) {
                               Optional<Pizza> result = PizzaRepository.findById( id );

                               if (result.isPresent()) {
                                   model.addAttribute( "pizza", result.get() );
                                   return "pizzas/edit";
                               } else {
                                   throw new ResponseStatusException( HttpStatus.NOT_FOUND, "book with id " + id + " not found" );
                               }

                           }

-si crea il tempalte per la edit



                      <!doctype html>
                      <html lang="en" xmlns:th="http://www.thymeleaf.org">
                      <head th:insert="fragments/resources :: headResources('Edit Pizza')">

                      </head>

                      <body>

                      <nav th:replace="fragments/navbar :: topNavbar('pizzas')"></nav>
                      <div class="container my-5">
                          <h1>Edit a pizza</h1>
                      </div>

                      </body>
                      </html>


-ora si inserisce il form -> molto simile alla create cambia il th:action="@{/pizzas/edit/update/{id}(id=${pizza.id})}"
-i campi saranno già riempiti perchè quando gli passo la pizza con l'id io gli passo ua pizza già fatta con tutti i valori già definiti


                       <form id="pizza-edit" method="POST" th:action="@{/pizzas/edit/update/{id}(id=${pizza.id})}" th:object="${pizza}"
                                     class="row gy-2">
                                   <div class="mb-3">
                                       <label for="name" class="form-label">Name</label>
                                       <input type="text" class="form-control" id="name" th:field="*{name}" th:errorClass="is-invalid">
                                       <div th:if="${#fields.hasErrors('name')}" class="invalid-feedback">
                                           <ul>
                                               <li th:each="err : ${#fields.errors('name')}" th:text="${err}"></li>
                                           </ul>
                                       </div>
                                   </div>
                                   <div class="mb-3">
                                       <label for="description" class="form-label">Insert description</label>
                                       <textarea class="form-control" id="description" rows="3" th:field="*{description}"
                                                 th:errorClass="is-invalid"></textarea>
                                       <div th:if="${#fields.hasErrors('description')}" class="invalid-feedback">
                                           <ul>
                                               <li th:each="err : ${#fields.errors('description')}" th:text="${err}"></li>
                                           </ul>
                                       </div>
                                   </div>
                                   <div class="mb-3">
                                       <label for="photo_url" class="form-label">Insert image</label>
                                       <input type="text" class="form-control" id="photo_url" th:field="*{photo_url}"
                                              th:errorClass="is-invalid">
                                       <div><img class="my-2" th:src="*{photo_url}" style="max-width: 100px; max-height: 100px;"/></div>
                                       <div th:if="${#fields.hasErrors('photo_url')}" class="invalid-feedback">
                                           <ul>
                                               <li th:each="err : ${#fields.errors('photo_url')}" th:text="${err}"></li>
                                           </ul>
                                       </div>
                                   </div>
                                   <div class="mb-3">
                                       <label for="price" class="form-label">Insert price</label>
                                       <input type="number" class="form-control" id="price" th:field="*{price}" th:errorClass="is-invalid">
                                       <div th:if="${#fields.hasErrors('price')}" class="invalid-feedback">
                                           <ul>
                                               <li th:each="err : ${#fields.errors('price')}" th:text="${err}"></li>
                                           </ul>
                                       </div>
                                   </div>

                                   <div>
                                       <button class="btn btn-primary" type="submit">Save</button>
                                       <a th:href="@{/pizzas}" class="btn bg-danger text-white">Cancel</a>
                                   </div>
                               </form>


-ora il prossimo passo è il controller di update con il metodo post che si collega a /pizzas/edit/update/{id}


                                 @PostMapping("/edit/update/{id}")
                                    public String update(@PathVariable Integer id, @Valid @ModelAttribute("pizza") Pizza formPizza, BindingResult BindingResult) {

                                        if (BindingResult.hasErrors()) {
                                            return "pizzas/edit";
                                        }
                                        Pizza savedPizza = PizzaRepository.save( formPizza );
                                        return "redirect:/pizzas";
                                    }

-Il problema è il created_at è stao cancellato perchè non è un campo del form e quindi con il submit non viene
salvato

-così facendo prendo e setto solo i dati che cambiano e updato il create_at rimane invariato e gli passo pizzaToEdit
invece di formPizza(che è quella totalmente nuova). pizzaToEdit contiene gli elementi nuovi ma anche quelli già presenti in database

                                      @PostMapping("/edit/update/{id}")
                                         public String update(@PathVariable Integer id, @Valid @ModelAttribute("pizza") Pizza formPizza, BindingResult BindingResult) {

                                             if (BindingResult.hasErrors()) {
                                                 return "pizzas/edit";
                                             }
                                             Pizza pizzaToEdit = PizzaRepository.findById( id ).orElseThrow( () -> new ResponseStatusException( HttpStatus.NOT_FOUND ) );
                                             pizzaToEdit.setName( formPizza.getName() );
                                             pizzaToEdit.setDescription( formPizza.getDescription() );
                                             pizzaToEdit.setPhoto_url( formPizza.getPhoto_url() );
                                             pizzaToEdit.setPrice( formPizza.getPrice() );

                                             Pizza savedPizza = PizzaRepository.save( pizzaToEdit );
                                             return "redirect:/pizzas";
                                         }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

        DELETE

-Iniziamo creando l'icona con il pulsante di delete che sarà un form perchè abbiamo il metodo post


                         <form th:action="@{/pizzas/delete/{id}(id=*{id})}" method="POST">

                              <button type="submit" class="btn bg-danger text-light"><i class="fa-solid fa-trash"></i></button>
                          </form>

-creiamo il controller


                                @PostMapping("/delete/{id}")
                                public String delete(@PathVariable Integer id) {

                                    Pizza pizzaToDelete = PizzaRepository.findById( id ).orElseThrow( () -> new ResponseStatusException( HttpStatus.NOT_FOUND ) );
                                    PizzaRepository.deleteById( id );
                                    return "redirect:/pizzas";
                                }


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


        RELAZIONi

    ONE TO MANY


 -creiamo la nuova entità offerte speciali in cui mettiamo tutte le colonne
 -  @ManyToOne
    private Pizza pizza; -> questo crea la relazione con Pizza e abbiamo un elemento pizza anchw qui dentro


                @Entity
                @Table(name = "special_offer")
                public class SpecialOffer {

                    @Id
                    @GeneratedValue(strategy = GenerationType.IDENTITY)
                    private Integer id;

                    private LocalDate startDate;
                    private LocalDate endDate;

                    private String title;

                    @ManyToOne
                    private Pizza pizza;

                    (getter e setter...)


-Nella classe Pizza aggiungo una lista di specialOffer in una lista e metto il tipo di relazione

                 @OneToMany(mappedBy = "pizza")
                  private List<SpecialOffer> specialOffer;

-fare i getter e setter di Pizza per specialOffer


-rilancio il database

- vado in show e faccio la tabella con le offerte



                   <section>

                          <h1>Create a new offer</h1>
                             <h2 class="text-muted" th:text="${specialOffer.pizza.name}"></h2>

                             <div>
                                 <form id="offer-create" method="POST" th:action="@{/special_offer/create/store}" th:object="${specialOffer}"
                                       class="row gy-2">
                                     <div class="mb-3">
                                         <label for="title" class="form-label">Titolo</label>
                                         <input type="text" class="form-control" id="title" th:field="*{title}" th:errorClass="is-invalid">
                                         <div th:if="${#fields.hasErrors('title')}" class="invalid-feedback">
                                             <ul>
                                                 <li th:each="err : ${#fields.errors('title')}" th:text="${err}"></li>
                                             </ul>
                                         </div>
                                     </div>
                                     <div class="mb-3">
                                         <label for="startDate" class="form-label">Insert start date</label>
                                         <input type="date" class="form-control" id="startDate" th:field="*{startDate}"
                                                th:errorClass="is-invalid">
                                         <div th:if="${#fields.hasErrors('startDate')}" class="invalid-feedback">
                                             <ul>
                                                 <li th:each="err : ${#fields.errors('startDate')}" th:text="${err}"></li>
                                             </ul>
                                         </div>
                                     </div>
                                     <div class="mb-3">
                                         <label for="endDate" class="form-label">Insert end date</label>
                                         <input type="date" class="form-control" id="endDate" th:field="*{endDate}"
                                                th:errorClass="is-invalid">
                                         <div th:if="${#fields.hasErrors('endDate')}" class="invalid-feedback">
                                             <ul>
                                                 <li th:each="err : ${#fields.errors('endDate')}" th:text="${err}"></li>
                                             </ul>
                                         </div>
                                     </div>
                                     <div>
                                         <button class="btn btn-primary" type="submit">Save</button>
                                         <a th:href="@{/pizzas/show/{pizzaId}(pizzaId=*{pizza.id})}" class="btn bg-danger text-white">Cancel</a>
                                     </div>
                                 </form>

                             </div>


- creiamo un nuovo controller per le offerte -> SpecialOfferController che mi manda a special_offer/form

        @Controller
        @RequestMapping("/special_offer")
        public class SpecialOfferController {


            //CREATE

            @GetMapping("/create")
            public String create() {
                return "specialOffer/form";
            }
         }

-creiamo l'htlm dentro una nuova directory specialOffer e dentro form

-vado in show e metto il collegamanto

          <a th:href="@{/special_offer/create}"

-però è utile portarsi dietro l'id della pizza torniamo nel controller e gli passiamo il request param

               @GetMapping("/create")
               public String create(@RequestParam Integer pizzaId) {
                   return "specialOffer/form";
               }

-Poi nel template

          <a th:href="@{/special_offer/create(pizzaId=*{id})}"
          ><i class="fa-solid fa-circle-plus"></i></a>

-completiamo il controller in cui creiamo un oggetto SpecialOffer che conterra i dati el form
-aggiungo la   specialOffer.setStartDate( LocalDate.now() ); -> così la ho anchè nella create

           @GetMapping("/create")
              public String create(@RequestParam Integer pizzaId, Model model) {
                  SpecialOffer specialOffer = new SpecialOffer();
                  specialOffer.setStartDate( LocalDate.now() );
                  model.addAttribute( "specialOffer", new SpecialOffer() );
                  return "specialOffer/form";
              }

-devo aggiungere nelle application

              spring.mvc.format.date=yyyy-MM-dd
              spring.mvc.format.date-time=yyyy-MM-dd HH:mm:ss
              spring.mvc.format.time=HH:mm:ss

- iplementiamo il form

             @GetMapping("/create")
                public String create(@RequestParam Integer pizzaId, Model model) {
                    Pizza pizza = pizzaRepository.findById( pizzaId ).orElseThrow( () -> new ResponseStatusException( HttpStatus.NOT_FOUND ) );
                    SpecialOffer specialOffer = new SpecialOffer();
                    specialOffer.setStartDate( LocalDate.now() );
                    specialOffer.setPizza( pizza );
                    model.addAttribute( "specialOffer", specialOffer );
                    return "specialOffer/form";
                }

-nell' html possiamo mettere il nome della pizza e anche l'oggetto pizza ma come hidden così lo passiamo
nel form

                <h2 class="text-muted" th:text="${specialOffer.pizza.name}"></h2>
                <div>
                     <input type="hidden" id="pizza" th:field="*{pizza}">
                </div>


-bisogna fare lo store


                @PostMapping("/create/store")
                  public String store(@Valid @ModelAttribute("specialOffer") SpecialOffer formSpecialOffer, BindingResult bindingResult) {
                      if (bindingResult.hasErrors()) {
                          return "specialOffer/form";
                      }
                      SpecialOffer savedSpecialOffer = specialOfferRepository.save( formSpecialOffer );
                      return "redirect:/pizzas/show/" + savedSpecialOffer.getPizza().getId();
                  }


       //EDIT

-inseriamo il link nello show


                 <td>
                    <a th:href="@{/special_offer/edit/{id}(id=*{id})}" title="edit"><i
                     class="fa-solid fa-pen-to-square"></i></a>
                 </td>

-creiamo il controller

                  @GetMapping("/edit/{id}")
                    public String edit(@PathVariable Integer id, Model model) {
                        Optional<SpecialOffer> result = specialOfferRepository.findById( id );

                        if (result.isPresent()) {
                            model.addAttribute( "specialOffer", result.get() );
                            return "specialOffer/edit";
                        } else {
                            throw new ResponseStatusException( HttpStatus.NOT_FOUND, "special offer with id " + id + " not found" );
                        }


                    }

-creiamo il tempalte che è uguale al create form

- creiamo il collegamanto con l'update

                   th:action="@{/special_offer/edit/update/{id}(id=${specialOffer.id})}"

-creiamo l'update


                    @PostMapping("/edit/update/{id}")
                    public String update(@PathVariable Integer id, @Valid @ModelAttribute("specialOffer") SpecialOffer formSpecialOffer, BindingResult bindingResult) {

                        if (bindingResult.hasErrors()) {
                            return "specialOffer/edit";
                        }

                        SpecialOffer specialOfferToEdit = specialOfferRepository.findById( id )
                                .orElseThrow( () -> new ResponseStatusException( HttpStatus.NOT_FOUND ) );

                        specialOfferToEdit.setTitle( formSpecialOffer.getTitle() );
                        specialOfferToEdit.setStartDate( formSpecialOffer.getStartDate() );
                        specialOfferToEdit.setEndDate( formSpecialOffer.getEndDate() );


                        SpecialOffer updatedSpecialOffer = specialOfferRepository.save( specialOfferToEdit );

                        return "redirect:/pizzas/show/" + updatedSpecialOffer.getPizza().getId();
                    }



   //DELETE

- creare il form in show


                    <form th:action="@{/special_offer/delete/{id}(id=*{id})}" method="POST"
                             onsubmit="return confirm('Are you sure?')">

                        <button type="submit" class="btn bg-danger text-light"><i
                           class="fa-solid fa-trash"></i>
                        </button>
                    </form>

-creiamo il controller

                     @PostMapping("/delete/{id}")
                         public String delete(@PathVariable Integer id) {

                             SpecialOffer specialOfferToDelete = specialOfferRepository.findById( id ).orElseThrow( () -> new ResponseStatusException( HttpStatus.NOT_FOUND ) );
                             specialOfferRepository.deleteById( id );
                             return "redirect:/pizzas/show/" + specialOfferToDelete.getPizza().getId();
                         }

-se volessi cancellare una pizza con un' offerta non funzionerebbe
-perchè c'è una relazione che lega i due elementi
-aggiungo cascade remove sulla  @OneToMany nel Model così a cascata mi elimina anche tutti gli elementi
special offer collegate

                    @OneToMany(mappedBy = "pizza", cascade = CascadeType.REMOVE)


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        MANY TO MANY


- creiamo una nuova entità


                            @Entity
                            @Table(name = "Ingredients")
                            public class Ingredients {

                                @Id
                                @GeneratedValue(strategy = GenerationType.IDENTITY)
                                private Integer id;
                                @NotNull
                                @NotBlank
                                @Column(nullable = false)
                                private String name;

                                public Integer getId() {
                                    return id;
                                }

                                public void setId(Integer id) {
                                    this.id = id;
                                }

                                public String getName() {
                                    return name;
                                }

                                public void setName(String name) {
                                    this.name = name;
                                }
                            }


- creiamo degli igredienti da mettere in tabella nelimpot sql scrivo


                              INSERT INTO ingredients (name) VALUES ('mozzarella');
                              INSERT INTO ingredients (name) VALUES ('pomodoro');
                              INSERT INTO ingredients (name) VALUES ('olive');
                              INSERT INTO ingredients (name) VALUES ('tonno');
                              INSERT INTO ingredients (name) VALUES ('verdure');
                              INSERT INTO ingredients (name) VALUES ('funghi');

-inserisco una lista di ingredienti in pizza e creo la relazione

                                @ManyToMany
                                private List<Ingredients> ingredients;

-faccio partire il programma

-creiamo un nuovo repository


                         @Repository
                         public interface IngredientsRepository extends JpaRepository<Ingredients, Integer> {
                         }

-Il pizza controller della create deve mandarci la lista di ingredienti nel tempalte

                            @Autowired
                            private IngredientsRepository ingredientsRepository;

in create


                              //CREATE
                                 @GetMapping("/create")
                                 public String create(Model model) {
                                     model.addAttribute( "pizza", new Pizza() );
                                     model.addAttribute( "ingredientsList", ingredientsRepository.findAll() );
                                     return "pizzas/create";
                                 }

nel template di create inserisco tutti i mei ingredienti


                       <div class="form-check" th:each="ing : ${ingredientsList}">
                            <input
                                    class="form-check-input"
                                    type="checkbox"
                                    th:value="${ing.id}"
                                    th:id="${'ing_' + ing.id}">
                                    th:field="*{ingridients}">
                            <label class="form-check-label" th:for="${'ing_' + ing.id}" th:text="${ing.name}">
                            </label>
                        </div>

-nella show

                   <h3>Ingredients</h3>
                   <ul th:if="${pizza.ingridients.size() > 0}">
                       <li th:each="ing : ${pizza.ingridients}" th:text="${ing.name}"></li>
                   </ul>
                   <div th:unless="${pizza.ingridients.size() > 0}" class="alert alert-info">The list is empty</div>


Da completare

//////////////////////////////////////////////////////////////////////////////////////////////////////////


   LOGIN

-prima cosa dobbiamo importare uan dependency nel pom



                                <dependency>
                                    <groupId>org.springframework.boot</groupId>
                                    <artifactId>spring-boot-starter-security</artifactId>
                                </dependency>
                                <dependency>
                                    <groupId>org.springframework.security</groupId>
                                    <artifactId>spring-security-test</artifactId>
                                    <scope>test</scope>
                                </dependency>

-riavviamo l'applicazione

-ora avrò la login e non mi fa accedere a nulla
trovole le credenziali in console
Using generated security password: dc03000d-fc4f-4e20-9453-c8b70415a5e7

                        username: user
                        password: dc03000d-fc4f-4e20-9453-c8b70415a5e7


- creo nuova entità User


                       @Entity
                       @Table(name = "users")
                       public class User {

                           @Id
                           @GeneratedValue(strategy = GenerationType.IDENTITY)
                           private Integer id;

                           @NotBlank
                           private String firstName;
                           @NotBlank
                           private String lastName;
                           @NotBlank
                           @Email
                           private String email;

                           private LocalDateTime registeredAt;

                           private String password;

                           @ManyToMany(fetch = FetchType.EAGER)
                           private Set<Role> roles = new HashSet<>();

                           public Integer getId() {
                               return id;
                           }

                           public void setId(Integer id) {
                               this.id = id;
                           }

                           public String getFirstName() {
                               return firstName;
                           }

                           public void setFirstName(String firstName) {
                               this.firstName = firstName;
                           }

                           public String getLastName() {
                               return lastName;
                           }

                           public void setLastName(String lastName) {
                               this.lastName = lastName;
                           }

                           public String getEmail() {
                               return email;
                           }

                           public void setEmail(String email) {
                               this.email = email;
                           }

                           public LocalDateTime getRegisteredAt() {
                               return registeredAt;
                           }

                           public void setRegisteredAt(LocalDateTime registeredAt) {
                               this.registeredAt = registeredAt;
                           }


                           public String getPassword() {
                               return password;
                           }

                           public void setPassword(String password) {
                               this.password = password;
                           }

                           public Set<Role> getRoles() {
                               return roles;
                           }

                           public void setRoles(Set<Role> roles) {
                               this.roles = roles;
                           }
                       }

-Creo anche una nuova entità Role per definire che ruolo ha questo user




                        @Entity
                        @Table(name = "roles")
                        public class Role {

                            @Id
                            private Integer id;
                            private String name;

                            public Integer getId() {
                                return id;
                            }

                            public void setId(Integer id) {
                                this.id = id;
                            }

                            public String getName() {
                                return name;
                            }

                            public void setName(String name) {
                                this.name = name;
                            }
                        }

-riavviamo l'applicazione
-facciamoci degli utenti di prova


                         INSERT INTO roles (id, name) VALUES(1, 'ADMIN');
                         INSERT INTO roles (id, name) VALUES(2, 'USER');

                         INSERT INTO users (email, first_name, last_name, registered_at, password) VALUES('john@email.com', 'John', 'Doe', '2023-11-20 10:35', '{noop}john');
                         INSERT INTO users (email, first_name, last_name, registered_at, password) VALUES('jane@email.com', 'Jane', 'Smith', '2023-11-20 10:35','{noop}jane');

                         INSERT INTO users_roles (user_id, roles_id) VALUES(1, 1);
                         INSERT INTO users_roles (user_id, roles_id) VALUES(1, 2);
                         INSERT INTO users_roles (user_id, roles_id) VALUES(2, 2);


-riavviamo

-ci serve UserDetail e lo creo facendo un nuovo package che chiamo security e ci metto dentro la
classe DatabaseUserDetails che implementa UserDetails che è una interfaccia di Spring


                          public class DatabaseUserDetails implements UserDetails {

                              private Integer id;
                              private String username;
                              private String password;
                              private Set<GrantedAuthority> authorities = new HashSet<>();


                              @Override
                              public Collection<? extends GrantedAuthority> getAuthorities() {
                                  return this.authorities;
                              }

                              @Override
                              public String getPassword() {
                                  return this.password;
                              }

                              @Override
                              public String getUsername() {
                                  return this.username;
                              }

                              @Override
                              public boolean isAccountNonExpired() {
                                  return true;
                              }

                              @Override
                              public boolean isAccountNonLocked() {
                                  return true;
                              }

                              @Override
                              public boolean isCredentialsNonExpired() {
                                  return true;
                              }

                              @Override
                              public boolean isEnabled() {
                                  return true;
                              }

                              public Integer getId() {
                                  return id;
                              }
                          }

-ora faccio un costruttore di DatabaseUserDetails

                              public DatabaseUserDetails(User user) {
                                  this.id = user.getId();
                                  this.username = user.getEmail();
                                  this.password = user.getPassword();
                                  for (Role role : user.getRoles()) {
                                      this.authorities.add(new SimpleGrantedAuthority(role.getName()));
                                  }

-creo la UserRepository


                                public interface UserRepository extends JpaRepository<User, Integer> {

                                    Optional<User> findByEmail(String email);
                                }

-creo la DataBaseUserDetailsService


                                   @Service
                                   public class DatabaseUserDetailsService implements UserDetailsService {

                                       @Autowired
                                       private UserRepository userRepository;

                                       @Override
                                       public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
                                           Optional<User> loggedUser = userRepository.findByEmail(username);
                                           if (loggedUser.isPresent()) {
                                               return new DatabaseUserDetails(loggedUser.get());
                                           } else {

                                               throw new UsernameNotFoundException(username);
                                           }
                                       }
                                   }

- creo la classe configuration SecurityConfiguration



                                            @Configuration
                                            public class SecurityConfiguration {


                                                @Bean
                                                public DatabaseUserDetailsService userDetailsService() {
                                                    return new DatabaseUserDetailsService();
                                                }


                                                @Bean
                                                public PasswordEncoder passwordEncoder() {
                                                    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
                                                }

                                                @Bean
                                                public DaoAuthenticationProvider authenticationProvider() {
                                                    // creo un DaoAuthenticationProvider
                                                    DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
                                                    // gli assegno lo UserDetailsService
                                                    provider.setUserDetailsService( userDetailsService() );
                                                    // gli assegno il PasswordEncoder
                                                    provider.setPasswordEncoder( passwordEncoder() );
                                                    return provider;
                                                }

                                                @Bean
                                                public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

                                                    http
                                                            .authorizeHttpRequests()
                                                            .requestMatchers( "/ingredients" ).hasAuthority( "ADMIN" )
                                                            .requestMatchers( "/users" ).hasAuthority( "ADMIN" )
                                                            .requestMatchers( "/special_offer/**" ).hasAuthority( "ADMIN" )
                                                            .requestMatchers( HttpMethod.POST, "/pizzas/**" ).hasAuthority( "ADMIN" )
                                                            .requestMatchers( "/pizzas", "/pizzas/**" ).hasAnyAuthority( "ADMIN", "USER" )
                                                            .requestMatchers( "/**" ).permitAll()
                                                            .and().formLogin()
                                                            .and().logout();
                                                    return http.build();
                                                }

                                            }

-riavviamo l'applicazione e testiamo chi può e chi non può fare certe azioni
-ora dobbiamo fare in modo che solo chi ha i permessi veda certe icone o pulsanti
-inseriamo una nuova dependency


                                            <dependency>

                                              <groupId>org.thymeleaf.extras</groupId>

                                              <artifactId>thymeleaf-extras-springsecurity6</artifactId>

                                            </dependency>


-ora partiao dalla navbar e togliamo user inseriamo xmlns

                                   xmlns:sec="http://www.thymeleaf.org"

-ora nel <li> mettiamo il sec se refresho non vedo più (con Jane)  user

                                    sec:authorize="hasAuthority('ADMIN')"

-posso metterlo ovunque mi serva

-posso aggiungere nella mia navbar il nome dello user e il logout



                    <div class="text-light">
                        Hi <span sec:authentication="name"></span>
                        <a th:href="@{/logout}" class="btn btn-light">Logout</a>
                    </div>

-se voglio creare una pagina dell'utente mi serve il controller dello User


                        @Controller
                        @RequestMapping("/users")
                        public class UserController {

                            @Autowired
                            UserRepository userRepository;

                            @GetMapping
                            public String index(Authentication authentication, Model model) {

                                DatabaseUserDetails principal = (DatabaseUserDetails) authentication.getPrincipal();
                                User loggedUser = userRepository.findById(principal.getId()).get();
                                model.addAttribute(loggedUser.getFirstName());
                                model.addAttribute(loggedUser.getLastName());

                                return "users/index";
                            }


                        }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        API


-creo nuova classe PizzaRestController nel package api



                                @RestController
                                @RequestMapping("/api/v1/pizzas")
                                @CrossOrigin
                                public class PizzaRestController {

                                }

-vado in securityConfiguration e aggiungo


                                   http.csrf().disable();

-endpoint per la lista di tutti i libri


                             @RestController
                             @RequestMapping("/api/v1/pizzas")
                             @CrossOrigin
                             public class PizzaRestController {

                                 private final PizzaRepository pizzaRepository;


                                 public PizzaRestController(PizzaRepository pizzaRepository) {
                                     this.pizzaRepository = pizzaRepository;
                                 }

                                 @GetMapping
                                 public ResponseEntity<List<Pizza>> getPizzas(@RequestParam Optional<String> search) {
                                     List<Pizza> pizzaList;
                                     if (search.isPresent()) {
                                         pizzaList = pizzaRepository.findByNameContainingIgnoreCase(search.get());
                                     } else {
                                         pizzaList = pizzaRepository.findAll();
                                     }


                                     return new ResponseEntity<>(pizzaList, HttpStatus.OK);
                                 }
                             }

-se voglio aggiungere una special offer non mi funziona più e devo aggiungere nel Model di Pizza



                                         @JsonIgnore
                                          private List<SpecialOffer> specialOffer;


-se voglio i dettagli della pizza



                         @GetMapping("/{id}")
                            public ResponseEntity<Pizza> getPizzaDetails(@PathVariable Integer id) {
                                Optional<Pizza> optionalPizza = pizzaRepository.findById( id );
                                if (optionalPizza.isPresent()) {
                                    Pizza pizza = optionalPizza.get();
                                    return new ResponseEntity<>( pizza, HttpStatus.OK );
                                } else {
                                    throw new ResponseStatusException( HttpStatus.NOT_FOUND, "Pizza not found with ID: " + id );
                                }

                            }


-se voglio una create


                    public ResponseEntity<Pizza> create(@Valid @RequestBody Pizza pizza) {
                        try {

                            Pizza newPizza = pizzaRepository.save( pizza );

                            return new ResponseEntity<>( newPizza, HttpStatus.CREATED );
                        } catch (Exception e) {

                            throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Error creating pizza", e );
                        }

                    }

- Se voglio la Edit




                        @PutMapping("/{id}")
                        public ResponseEntity<Pizza> update(@PathVariable Integer id, @Valid @RequestBody Pizza updatedPizza) {

                            Pizza existingPizza = pizzaRepository.findById( id )
                                    .orElseThrow( () -> new ResponseStatusException( HttpStatus.NOT_FOUND, "Pizza with id " + id + " not found" ) );

                            existingPizza.setName( updatedPizza.getName() );
                            existingPizza.setDescription( updatedPizza.getDescription() );
                            existingPizza.setPhoto_url( updatedPizza.getPhoto_url() );
                            existingPizza.setPrice( updatedPizza.getPrice() );

                            Pizza savedPizza = pizzaRepository.save( existingPizza );

                            return ResponseEntity.ok( savedPizza );
                        }


-Se voglio la delete




                  @DeleteMapping("/{id}")
                     public ResponseEntity<Void> delete(@PathVariable Integer id) {

                             Pizza pizzaToDelete = pizzaRepository.findById(id)
                                     .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Pizza with id " + id + " not found"));

                             pizzaRepository.deleteById(id);

                             return ResponseEntity.noContent().build();

                     }